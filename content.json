{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/08/hello-world/"},{"title":"test\\_my\\_site","text":"代码可读性 Array 函数式方法 filter map forEach some everygit 教程http://sourceforge.net/projects/git-osx-installer/git flowgit checkoutmaster 链路 —- commit id a ==clone ==&gt; commit a =&gt; b =&gt; commit b =&gt; c ——–| feature 分支合并到 master ，如果出现冲突，需要将 master 分支合并到 feature 分支，解决完冲突，再合并回 master git pull gitlab教程 SSH设置https://www.jianshu.com/p/142b3dc8ae15 本地git操作git init // 在本地初始化一个git仓库git add &lt;文件名.后缀&gt;git commit -m “本次提交的附加说明” // 以上两个命令完成本地仓库的新文件添加。注意：当文件已经添加完，下一次修改后，在commit前仍然需要add一次，否则会报错 远程同步1.第一次关联远程库：git remote add origin git@server-name:path/repo-name.git2.第一次把本地库的所有内容推送到远程仓库上：git push -u origin master由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。)(./1555404715718.png) 以后再推：$ git push origin master （不需要-u了） 创建/合并分支git checkout -b dev //创建并切换到dev分支， -b参数表示创建并切换git branch // 列出所有分支git checkout master // 切换到master分支，仅切换不新建git merge {指定分支名} // git merge命令用于合并指定分支到当前分支git branch -d dev // 删除dev分支 git merge –no-ff -m “merge with no-ff” dev //–no-ff参数，表示禁用Fast forward，合并后的历史有分支，能看出来曾经做过合并 团队合作策略)(./1555464449748.png) bug修复git stash // 出现bug时，手上的开发的分支还没开发完没法提交，可以用这个命令来储存工作进度假设当前在开发喵分支，出了bug，要切一个master的分支来进行修复，首先要checkout切换到master分支，再checkout -b issue-101 创建bug分支 git stash list // 查看已经存储的工作现场，可以是多个 git stash pop // 恢复并切换到修复bug之前的工作现场，并删除存储的工作现场。注意：使用这个命令之前要先切换回平时用来开发的那个分支git checkout dev Feature分支git branch -D &lt;分支名&gt; //如果平时主要在dev上开发，每个新功能最好从Dev单独切Feature分支进行开发。如果功能突然要取消，不合并到dev就要删除，需要使用大写-D命令，原本的小写-d只能用于分支合并后的删除 多人协作git push origin &lt;分支名&gt; // 把本地分支的最新修改推送到远程git push -u origin master //第一次推送master分支时，加上-u参数，除了将本地master推送到远程仓库外，还会把本地master分支和远程master分支关联起来 git branch –set-upstream-to=origin/&lt;远程分支名&gt; //当pull的时候，如果报错说本地分支和线上分支没有建立对应关系，使用该命令创建关系。如果本地分支名和远程分支名不一样，把上述命令中的=改成本地分支名 git pull // 小伙伴的最新提交和你试图推送的提交有冲突时，用这个命令把最新提交把最新的提交从origin/dev抓下来 git commit -m “fix env conflict” // git checkout -b branch-name origin/branch-name // 在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致 git remote -v // 查看远程库信息 基础知识1.交换两个变量的值，不使用第三个变量var n1 = 5var n2 = 6n1 = n1 + n2n2 = n1 - n2n1 = n1 - n2 2.获取变量的类型typeof 3.类型转换转字符串：toString()用于一般值 String()用于undefined和null转数值：Number(‘1a’) //NaN 如果要转换的字符串中有一个不是数值的字符，返回NaNparseInt(‘1.2a’) // 1 parseInt(‘abc123’) //NaN 如果第一个字符是数字会解析直到 遇到非数字结束parseFloat() 和parseInt很像parseFloat会解析第一个. 遇到第二个.或者非数字结 束 4.逻辑运算&amp;&amp; 与|| 或! 非 5.布尔值的隐式转换转换为true 非空字符串 非0数字 true 任何对象转换成false 空字符串 0 false null undefined 6.数组操作练习翻转数组 - 4, 5, 7, 9 ——&gt; 9, 7, 5, 4var nums = 4, 5, 7, 9var newArray = for(let i = nums.length - 1; i &gt;= 0; i–) {let a = numsinewArray.push(a)}console.log(newArray) 冒泡排序 - 从小到大的排序var nums = 97, 68, 72, 29, 51, 54//外层循环控制趟数，内层循环控制每次要比较的次数for(let i = 0; i &lt; nums.length - 1; i++) {for(let j = 0; j &lt; nums.length - 1 - i; j++) {if ( numsj &gt; numsj + 1 ) {let tmp = numsjnumsj = numsj + 1numsj + 1 = temp}}}console.log(nums) 6.作用域局部变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁 作用域链概念：凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 7.this 函数在定义的时候this是不确定的，只有在调用的时候才可以确定 一般函数直接执行，内部this指向全局window 函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化在函数中，this指向window在方法中，this指向这个方法所属的对象在构造函数中，this指向构造函数所创造的对象 8.array常用方法arr.push(‘1’)arr.pop() //删除数组中最后一项并返回arr.shift() //删除数组中的第一个元素，修改length属性arr.unshift() //往数组的最前面插入项，返回数组长度arr.sort() //从小到大排序arr.indexOf(4) //找到某个元素在数组中的索引值arr.slice(0, 1) //从当前数组中截取一个新数组，不改变原来的数组(复制数组用 array.slice(0) 实现)arr.concat(1, 2, 3) //返回一个拼接后的数组，并且不改变原来的两个数组arr.join(‘ | ‘) //把数组中的元素通过传入的内容拼接成一个字符串儿arr.includes(element) //判断元素是否在数组中 9.字符串常用方法str.spilt(‘=’) //把字符串从传入的字符处隔成一个数组indexOf() //返回指定内容在元字符串中的位置 10.Date常用方法var d = new Date(); //获取当前时间d.getTime() //返回毫秒值var time = new Date(1498099000356) //把传入的毫秒值转换为年月日var now = + new Date() //直接返回当前时间的毫秒值 11.函数的其他成员function fn(x, y, z) { console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字} 12.循环object的方法Object.keys // 获取包含对象所有 key 的数组let obj = { foo: 1, bar: 2,}Object.keys(obj)结果是 “foo”, “bar” React几大主流技术的关系Angular, Vue, React 这三个都是前端框架，我们在进行混合App开发的时候，只是用到了这三个框架的基础语法而已；Ionic， Weex， ReactNatvie 这三个都是打包工具，能够把我们开发出来的应用，最终打包成一个可安装的手机端程序安装包；同时，这三个东西，也提供了好用的一些小组件； 为什么学React设计优秀，基于组件化，方便代码的重用开发团队实力强大，不用担心断更；结合RN可以开发移动App，实现跨平台，并且体验相对不错； JSX语法规范作用：在JS文件中书写类似HTML的代码，快速定义虚拟DOM结构本质：还是把书写的HTML代码转换成了React.creatElement的形式在JSX中，如果要为元素添加class属性了，那么，必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor{}花括号里的语句会当成JS执行 子父组件通信：refreshBox是父组件创建的一个回调函数，将其传入Son组件中，然后通过Son组件进行调用触发http://www.cnblogs.com/tim100/p/6050514.html Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组const object1 = { foo: ‘bar’, baz: 42 };console.log(Object.entries(object1)); Array Array [“foo”, “bar”, Array “baz”, 42] Array.forEach() 方法对数组的每个元素执行一次提供的函数，执行的Callback函数接收3个参数，分别是：当前循环到的元素、当前元素的索引index（可选）、正在操作的数组array（可选）)(./1551954701434.png) 数组的map用法 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)(./1548033409820.png)配合属性扩散 输入框的ref属性获取value)(./1548138022328.png) Route的用法和link标签配合使用，达成切换tab到不同页面的目的给tab加上对应的链接标签：&lt;Link to={‘/about’}&gt;关于&lt; /Link&gt;把不同链接和组件关联上，并给组件占位&lt; Route path=”/home” component={HomeContainer(组件名)} &gt;&lt; /Route &gt; 箭头函数特性：箭头函数外部和内部的this要保持一致 获取地址栏的方法：window.location 获取路由的方法 在react里写css，属性名称似乎不可以用‘-’，如text-align属性名 选择第几页后，更改加载的url，用 this.props.history.push(‘url’) 方法)(./1548401675985.png) setState在什么情况下是同步，什么情况下是异步：setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 CSS line-height行高等于高度文字可以垂直居中 行内元素是只有左右内外边距的，是没有上下内外边距的 盒子水平居中。居中对齐元素一定要有宽。并且元素在标准流里)(./1549001599502.png) 为了网页的兼容性，在一开始清除body和所有元素标签的内外边距，达成在所有浏览器显示一致的目的 块元素嵌套发生外边距塌陷会导致里面的盒子无法和外面的盒子有间距，解决方案是给父元素定义1像素的边框或上内边距 或 父元素 overflow：hidden inline-block特性：可以一行放多个；有高度和宽度；盒子大小由内容决定 清除浮动：解决子元素浮动，父元素没有高度的时候，子元素不会撑开父元素的高度，导致下一行的块元素上移的问题推荐解决方案如下)(./1549094854428.png) 去除输入框默认样式)(./1549184147976.png) 子盒子垂直居中的三种方法 使用绝对定位，下移父盒子高度一半，再上移子盒子本身高度的一半 直接设置上边距 （父盒子高度-子盒子高度-子盒子边框）/2 父盒子display：table-cell，子盒子 vertical-align：center 10.子盒子水平居中的四种方法 margin: 0 auto 把盒子转换为行内块，设置 text-align:center 直接设置左边距 （父盒子宽度-子盒子宽度-子盒子边框）/2 。只适用于固定宽度值的情况 设置绝对定位，先向右移动父亲盒子宽度的一半，再往回移动（自己宽度+边框宽度）的一半 11.隐藏滚动条但是可以滚动::-webkit-scrollbar {display: none;} DOM querySelector的用法: element.querySelector(‘选择器’))(./1550474376310.png) 文本改编辑框的方法//task.contentEditable = true//task.focus() 更改按键事件的默认含义的方法)(./1550474864562.png) 操作元素的csselement.width = 320px 更改元素的内容element.innerHTML = 喵喵 eventloop node.js当js执行异步任务，只是发了个消息给c++，当c++轮询到事件结果时，再通知js)(./1553158286848.png)事件循环是多个阶段的交替过程： 1.timers2.I/O callback（对前端不重要）3.idle，prepare（对前端不重要）4.poll5.check6.close callback（对前端不重要） setTimeout(fn, 1000) 会把fn放到timers里面，并记录下在100ms后执行fn)(./1553164672343.png) 常用api：setTimeout timers阶段setImmediate checknextTick 当前阶段完了以后马上执行 题目举例)(./1553166054531.png) Chrome 1.宏任务2.微任务主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行。 作者：前端小姐姐链接：https://juejin.im/post/5c947bca5188257de704121d来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 例子 flexbox父盒子 display：flexmin-width：300px 整个盒子被挤压的最小宽度flex-direction：column 排列方式可以是水平也可以是垂直，默认是row（水平）justify-content：flex-end装不满的时候让子元素从后往前排列flex-wrap：wrap（换行）nowrap (不换行)子盒子 flex：1 这里的数字代表几份width: 100px 写了这个参数的子盒子宽度不变，其他盒子减去它的像素再按flex的值划分比例。写这个参数就不写flex：1 了 webpackwebpack 打包过程以 entry 为起点，将所依赖的模块组织成一个树形的结构通过不同的 loader 对不同的文件进行编译使用 plugins 对文件打包后的文件进行特定的操作根据 output 将打包后的文件输出到指定的位置webpack node.js掌握Node.js事件机制，常见模块使用，熟悉API调用1.事件驱动模型事件循环就是一个事件队列，先加入先执行，执行完一次队列，再遍历循环有没有新事件加入队列，执行中的事件叫IO事件，setImmediate在当前队列中立即执行，setTimeout/setInterval把执行定时到下一个队列，process.nextTick在当前队列执行完，下次遍历前执行。在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。)(./1552653107560.png)Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。EventEmitter 的核心就是事件触发与事件监听器功能的封装。 2.读取模块 let fs = require(‘fs’) 这里fs是文件读写模块，引入模块后就可以通过 模块.对象使用里面的方法3. fs.readdir(‘.’, (err, files) =&gt; {}) 读取目录，其中’.’是路径 fs.unlink(‘file’, (error)=&gt;{}) 删除 fs.writefile(file, ‘hello node’, (error)=&gt;{}) 写入 fs.readfile(file, (error, data) =&gt; {}) 读取文件4. const miaosync = (asyncall) =&gt; { setTimeout(() =&gt; { asyncall() }, 0)} 用同步的方法写异步5.Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎6.Node.js使用场景（理解：基于它是异步的）高并发实时聊天消息推送SPA单页面应用7.Node.js核心模块 EventEmitter 事件监听 on(event, listener(事件处理函数)) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 stream Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。FS 如上读写文件NET 全局对象 global setTimeout clearTimeout setInterval clearInterval console Express1.进公司以后先看下package.json里面依赖什么库2.导出模块module.exports{log: log //这是一个对象，后面的log是定义了方法的参数名 } 3.引入模块 const log = require(‘./utils’).log const {log} = require(‘./utils’) 用es6解包改写上面和react的import方式一致，但node原生不支持4.每个模块最后的执行代码要这样写，目的是当它被引入的时候不要执行，只有被直接打开的时候才执行if (require.main === module) {f1()}5.6.路由: 根据请求路径和请求方式进行路径分发处理http的常用请求方式：post 添加get 查询put 更新delete 删除 //根据单独的方法app.get(‘/‘, (req, res) =&gt; {res.send(‘get data’)}) //使用use分发可以处理所有类型的路由请求, 即同一路径的 post get put delete 请求都响应同一个结果app.use((req, res) =&gt; {res.send(‘ok’)}) app.listen(3000, ( ) =&gt; {console.log(‘runing…’)}) 7.中间件:处理过程中的一个环节, 从程序的角度就是一个函数app.use 应用级别的中间件)(./1552609107774.png) 路由级别中间件 use get post put delete 爬虫同步异步JS机制：单线程+事件队列)(./1551338129001.png) 事件队列中的任务执行条件：1、主线程已经空闲2、任务满足触发条件（只有以下三种情况会进入到事件队列）定时函数（延时时间已达到）事件函数（特定事件被触发）ajax的回调函数（服务器端游数据响应 ） 例子// console.log(1);// setTimeout(function(){ 回调函数会进队列,等后面的函数执行完了再执行// console.log(2); 输出结果 1 3 2// },10);// var sum = 0;// for(var i=0;i&lt;100000000;i++){// sum += i;// }// console.log(sum);// console.log(3); ajax和跨域是异步的用ajax更新页面不会刷新整个页面，ajax的回调函数最后才执行","link":"/2019/10/08/test-my-site/"}],"tags":[],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}