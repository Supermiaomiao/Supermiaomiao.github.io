{"pages":[{"title":"about~~~~","text":"","link":"/about/about.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"useCallback使用场景说明和举🌰","text":"useCallback 使用场景说明和举栗 使用 react hooks 时, 父组件向子组件传递函数 或 在 useEffect 中使用外部函数, 如果不做任何处理会出现 组件重复渲染 或 useEffect 中的逻辑被不停触发的情况, 一般这个时候 react-hooks 的 lint 也会报错。这种情况可以使用 useCallback 来将原函数包装一层再传到需要用的地方, 避免异常情况。 本文介绍了什么时候应该使用 useCallback, useCallback 如何和 React.memo() 配合使用, 并附上示例代码及gif截屏, 方便更直观的理解。 &lt;!—more—&gt; 基本用法把你要的函数用 useCallback 包一层, 定义好只有什么参数变化时, 这个被包过的函数才需要更新 123456789const yourfunc = useCallback( () =&gt; { // 你要写的函数逻辑 }, [ // 在数组里定义什么参数改变时才需要更新 yourfunc, // 只要这里的依赖的参数没有变对于任何使用它的一方它都没有变 ]) 使用场景 父组件向子组件传递函数时, 阻止传递的函数在每次 render 时重新创建，从而造成子组件 rerender。需要配合 React.memo() 一起使用。 在 useEffect（） 中使用外部创建的函数, 但不希望这个函数一直变化, 导致 useEffect 被重复触发。 栗子🌰 父组件传递函数给子组件 使用 useCallback 前，父组件直接传函数给子组件的方式。每次 app render 时, 传递的函数 () =&gt; setCount(count + 1) 都会重新创建一次。每次点击 hello 按钮，都会进行 render。 上图 log 是打在子组件 &lt;Hello \u0010/&gt; 中的, 从log可以看到, 每次点击按钮都会造成子组件 rerender。 使用 useCallback 前的父组件 1234567891011121314import React, { useState } from 'react'import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // 需要注意, 每次 render 传递的函数都会重新生成 // 也就是下面的 () =&gt; setCount(count + 1) return ( &lt;div&gt; &lt;Hello increment={() =&gt; setCount(count + 1)} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 子组件子组件中 React.memo() 的作用类似于 class 组件中的 shouldComponentUpdate, 会对组件接受到的 props进行浅比较, 如果 props 没有发生变化，组件就不会 rerender. 如果这里把 React.memo() 去掉, 那即使父组件使用 useCallback 改写。子组件 还是会 rerender。 1234567891011import React, { useRef } from 'react'// 使用 React.memo 使组件仅在 props 更新时更新// 未使用 useCallback 时, 由于每次传递过来的 increment 接到的函数都会更新, 子组件每次都会rerenderexport const Hello = React.memo(({ increment }) =&gt; { // 下面两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={increment}&gt;hello&lt;/button&gt;}) 使用 useCallback 改写父组件后, 每次更新数据组件不再重新渲染, 如图 使用 useCallback 改写原父组件, 子组件不需要修改1234567891011121314151617181920import React, { useState, useCallback } from 'react'import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // useCallback 仅将 setCount 作为依赖, 只要 setCount 不改变, // increment 函数就不会改变 // 相应的子组件接受到的 props 没改变, 就不会 rerender const increment = useCallback(() =&gt; { setCount(prevCount =&gt; prevCount + 1) }, [setCount]) return ( &lt;div&gt; &lt;Hello increment={increment} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 使用 map 渲染多个子组件并传递函数给它们 下面的计数器将一个数字构成的数组渲染成多个按钮, 点击按钮给 count 增加相应的值。与上面的例子不同的是, 这里的 increment 需要传入对应的数字, 进行相应计数。放上这个例子是为了说明, 如果 子组件要执行的函数 和 函数要用到的参数 都是父组件提供的, 最好把二者都传递给子组件在子组件执行。 改写前点击计数截图 会造成 rerender 的父组件函数传递方式 12345678910111213141516171819202122232425262728import React, { useState, useCallback } from 'react'import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) // 传递 () =&gt; increment(n), 而不是直接传递 increment // 仍然会造成每次 render 生成一个新的函数 return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num onClick={() =&gt; increment(n)} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 相应的子组件直接调用 onClick 123456789import React, { useRef } from 'react'export const Num = React.memo(({ onClick, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={onClick}&gt;{n}&lt;/button&gt;}) 改写后点击计数截图 改写后的 父组件1234567891011121314151617181920212223242526import React, { useState, useCallback } from 'react'import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num increment={increment} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 改写后的子组件 1234567export const Num = React.memo(({ increment, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={() =&gt; {increment(n)}}&gt;{n}&lt;/button&gt;})","link":"/2020/01/13/useCallback使用场景/"}],"tags":[],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}