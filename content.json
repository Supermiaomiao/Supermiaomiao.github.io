{"pages":[{"title":"about~~~~","text":"","link":"/about/about.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"git checkout/reset/revert/clean 区别","text":"这四个 git 命令主要用于修复错误时重置文件, 但是它们来取消变更什么区别和注意事项呢？ git checkout同时恢复工作区和暂存区, 参数是否带有文件名时表现不一致, 不带文件名时间 CHECKOUT BRANCH1.改变 HEAD 的指向到指定 branch2.把提交时的代码复制到暂存区(staging area)3.更新工作区(working area)的内容 CHECKOUT - - &lt;FILE&gt;1.将当前 暂存区 的文件覆盖到工作区。 CHECKOUT &lt;COMMIT&gt; - - FILE从指定的提交恢复文件, 也可以恢复删除的文件, 只要指定删除文件的那个提交的父提交即可1.从指定提交恢复对应文件到暂存区2.再从暂存区恢复对应文件到工作区 git clean删除工作区里未提交到暂存区的文件使用 –dry-run 查看会删除的文件, 使用 -f 执行删除, 使用 -d 清空文件夹 git reset根据后面所跟参数的不同有不一致的表现 RESET &lt;COMMIT&gt;根据 flag 的不同有如下表现—soft = 1—mix = 1 &amp; 2 默认是 mix—hard = 1 &amp; 2 &amp; 31.移动 HEAD 和 branch 到指定的提交&lt;COMMIT&gt;, 会改变提交历史2.重置暂存区的文件和指定提交一致3.重置工作区的文件和指定提交一致 GIT RESET — &lt;FILE&gt;不移动 HEAD, 将 HEAD 所指分支的对应文件覆盖到 暂存区 GIT RESET &lt;COMMI &gt; — &lt;FILE&gt;1.不移动 HEAD, 将指定提交的对应文件覆盖到暂存区 撤销 git resetgit reset ORIG_HEADgit 会将重置之前的 HEAD 存在 ORIG_HEAD 中, 执行 git reset ORIG_HEAD 可以回到(意外执行想要撤销的) git reset - 之前的状态 git revert &lt;commit&gt;更安全的 reset。直接取消对应提交的所有变更, 产生一个新的 commit, 不会改变变更历史 参考资料及图片来源git-in-depth Nina","link":"/2020/02/17/git-checkout-reset-revert-clean-区别/"},{"title":"container 基本原理","text":"在学习 docker 的具体操作之前, 先了解了一下 container 是什么及其基本原理, 以帮助自己更好的理解和学习。 为什么需要 Container 裸机自己购买硬件服务器, 需要操心硬件安全、维修、存放空间、温度、更新等，由于需要留有余量(防止流量上升时挂掉)需要为一部分平时不会用到的容量支付费用; 代码直接运行没有任何抽象层。同时好处是不需要和其他人共享存储和性能，数据更加安全。 虚拟机可以在一台服务器上安装和运行多个不同的操作系统作为虚拟机 。一台机器上的虚拟机之间是独立的, 文件系统独立, 经过资源管理后一个虚拟机当机不会影响另一个。相应的每个虚拟机都安装有性能上的开销。同时仍然需要自己维护硬件和软件。 公有云相比上一种方式不需要自己购买管理硬件机器, 而是直接向服务商租用虚拟机, 按需付费。其他优势和上面一样。服务商一般只提供硬件和硬件更新, 软件和网络等的更新需要自己维护。适用于没有子用户， 只在主机OS里写代码运行服务的场景。 Container轻量化，可以运行在同一个操作系统中。容器之间是相互独立的, 在提供了虚拟机的安全性和资源管理功能但不需要多安装和运行一个操作系统的额外开销。 Container核心功能container 的核心是使用以下 3 个 linux 的功能来实现隔离。 chroot (change root)chroot 解决的问题是，如果有两个用户在同一台主机的同一个操作系统里的运行进程，如何使双方无法查看和操作对方的文件。使用 chroot 命令后根目录/的挂载点会切换。 下图为使用后 chroot 后的效果 NameSpace虽然 chroot 环境可以阻止子进程之间查看对方的文件，但是使用 ps 它们仍然可以互相看到对方正在运行的进程，并进行干预。 使用命名空间可以限制一个 container 干扰其他 container 的能力。 新建一个/better-root 文件， 通过 unshare 命令创建一个新的独立的命名空间，对 /better-root 进行文件和进程隔离后，子进程 /better-root 只能看到自己的进程。主机仍然可以看到所有子进程。 主机也仍然可以控制子进程, 比如杀掉子进程下的某个进程 cGroups (controlgroups)增加对子进程的资源限制, 防止一个进程占用资源使整个服务器宕机。可以分别划分 cpu、内存、网络带宽等。 创建一个新的 croups 把进程加入 cgroup, 该进程及其所有的子进程都进入了这个cgroup 控制组 限制资源 80M 内存和 5%的 cpu 占用(多核) cgset -r cpu.cfs_period_us=100000 -r cpu.cfs_quota_us=$[ 5000 * $(getconf _NPROCESSORS_ONLN) ] sandboxcgset -r memory.limit_in_bytes=80M sandbox 运行本应占用更多资源的命令来检查资源的限制效果可以看到确实生效了 退出 chroot 环境再运行同样的命令对比 cpu 占用 总结通过以上三个步骤相当于手工创建了一个简易的 container, 分别实现了文件隔离(chroot)、资源隔离(namespace)和资源限制(cGroups)。使用 docker 的话 docker 会为我们完成这些工作。 学习资料https://btholt.github.io/complete-intro-to-containers/","link":"/2020/03/07/container/"},{"title":"useRef使用场景说明和举例","text":"使用场景 用于获取并存放组件的 dom 节点, 以便直接对 dom 节点进行原生的事件操作，如果监听事件或进行大小测量。 利用 useRef 解决由于 hooks 函数式组件产生闭包时无法获取最新 state 的问题。 存放想要持久化( instant )的数据, 该数据不和 react 组件树的渲染绑定。该数据可以是任何类型，数字、数组、对象、函数，都可以。 示例代码如下 用法获取 dom 节点React 的典型用法是更改 props 来更新UI，但有些情况如触发滚动时回调、获取元素大小等，需要直接获取并存储组件的 dom 节点的引用, 以便对其直接进行操作。 使用 useRef 存放并打印出的 dom 节点如图 示例代码如下 import React, { useRef } from 'react'export default function InputFocus() { const inputRef = useRef() return &lt;div&gt; &lt;input name=\"input\" ref={inputRef}&gt;&lt;/input&gt; &lt;button onClick={() =&gt; { // 通过 .current 拿到当前 dom 元素 // 可使用原生 dom 事件 inputRef.current.focus() console.log('ref', inputRef.current) }}&gt; focus &lt;/button&gt; &lt;/div&gt;} 解决使用 hooks 时由于闭包无法获取最新 state 的问题用 useRef 解决闭包导致无法获取最新 state 的问题。会出现这样的问题是由于 hooks 组件本质上是一个函数, 不像 class 组件由于可以直接获取到实例变量从而获取到准确的最新值。 下图为在 setTimeout 中进行弹窗并显示 state 和 ref.current 的值, 可以看到 state 的数字由于闭包拿到的是上一个版本的 state, 而 ref 的值更新了。 示例代码如下 import React, { useState, useEffect, useRef } from \"react\"const RefComponent = () =&gt; { // 使用 useState 存放和改变展示的 number const [stateNumber, setStateNumber] = useState(0) // 使用 useRef 生成一个独立的 ref 对象 // 在它的 current 属性单独存放一个展示的 number, 初始值为 0 const numRef = useRef(0) function incrementAndDelayLogging() { // 点击按钮 stateNumber + 1 setStateNumber(stateNumber + 1) // 同时 ref 对象的 current 属性值也 + 1 numRef.current++ // 定时器函数中产生了闭包, 这里 stateNumber 的是组件更新前的 stateNumber 对象, 所以值一直会滞后 1 setTimeout( () =&gt; alert(`state: ${stateNumber} | ref: ${numRef.current}`), 1000 ) } // 直接渲染的组件是正常情况, 可以获取到最新的 state, // 所以 ref.current 和 state 存储的值显示一致 return ( &lt;div&gt; &lt;h1&gt;solving closure by useRef&lt;/h1&gt; &lt;button onClick={incrementAndDelayLogging}&gt;alert in setTimeout&lt;/button&gt; &lt;h4&gt;state: {stateNumber}&lt;/h4&gt; &lt;h4&gt;ref: {numRef.current}&lt;/h4&gt; &lt;/div&gt; )}export default RefComponent 其他场景下存放任何想要存的数据可以在任何我们需要的时候更新 ref.current , 并且不会由于它的更新造成 rerender, 所以在下例中可以用它来计算组件更新次数。 import React, { useRef } from 'React'export const RenderCount() { const renders = useRef(0) console.log('renders:': renders.current++) // 组件每次渲染更新次数 return &lt;div&gt;Hello&lt;/div&gt;}","link":"/2020/02/17/useRef使用场景说明和举例/"},{"title":"useCallback使用场景说明和举栗","text":"使用 react hooks 时, 父组件向子组件传递函数 或 在 useEffect 中使用外部函数, 如果不做任何处理会出现 组件重复渲染 或 useEffect 中的逻辑被不停触发的情况, 一般这个时候 react-hooks 的 lint 也会报错。这种情况可以使用 useCallback 来将原函数包装一层再传到需要用的地方, 避免异常情况。 本文介绍了什么时候应该使用 useCallback, useCallback 如何和 React.memo() 配合使用, 并附上示例代码及gif截屏, 方便更直观的理解。 基本用法把你要的函数用 useCallback 包一层, 定义好只有什么参数变化时, 这个被包过的函数才需要更新 const yourfunc = useCallback( () =&gt; { // 你要写的函数逻辑 }, [ // 在数组里定义什么参数改变时才需要更新 yourfunc, // 只要这里的依赖的参数没有变对于任何使用它的一方它都没有变 ]) 使用场景1.父组件向子组件传递函数时, 阻止传递的函数在每次 render 时重新创建，从而造成子组件 rerender。需要配合 React.memo() 一起使用。 2.在 useEffect（） 中使用外部创建的函数, 但不希望这个函数一直变化, 导致 useEffect 被重复触发。 栗子🌰1.父组件传递函数给子组件 使用 useCallback 前，父组件直接传函数给子组件的方式。每次 app render 时, 传递的函数 () =&gt; setCount(count + 1) 都会重新创建一次。每次点击 hello 按钮，都会进行 render。 上图 log 是打在子组件 &lt;Hello \u0010/&gt; 中的, 从log可以看到, 每次点击按钮都会造成子组件 rerender。 使用 useCallback 前的父组件 import React, { useState } from 'react'import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // 需要注意, 每次 render 传递的函数都会重新生成 // 也就是下面的 () =&gt; setCount(count + 1) return ( &lt;div&gt; &lt;Hello increment={() =&gt; setCount(count + 1)} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 子组件子组件中 React.memo() 的作用类似于 class 组件中的 shouldComponentUpdate, 会对组件接受到的 props进行浅比较, 如果 props 没有发生变化，组件就不会 rerender. 如果这里把 React.memo() 去掉, 那即使父组件使用 useCallback 改写。子组件 还是会 rerender。 import React, { useRef } from 'react'// 使用 React.memo 使组件仅在 props 更新时更新// 未使用 useCallback 时, 由于每次传递过来的 increment 接到的函数都会更新, 子组件每次都会rerenderexport const Hello = React.memo(({ increment }) =&gt; { // 下面两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={increment}&gt;hello&lt;/button&gt;}) 使用 useCallback 改写父组件后, 每次更新数据组件不再重新渲染, 如图 使用 useCallback 改写原父组件, 子组件不需要修改import React, { useState, useCallback } from 'react'import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // useCallback 仅将 setCount 作为依赖, 只要 setCount 不改变, // increment 函数就不会改变 // 相应的子组件接受到的 props 没改变, 就不会 rerender const increment = useCallback(() =&gt; { setCount(prevCount =&gt; prevCount + 1) }, [setCount]) return ( &lt;div&gt; &lt;Hello increment={increment} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 使用 map 渲染多个子组件并传递函数给它们 下面的计数器将一个数字构成的数组渲染成多个按钮, 点击按钮给 count 增加相应的值。与上面的例子不同的是, 这里的 increment 需要传入对应的数字, 进行相应计数。放上这个例子是为了说明, 如果 子组件要执行的函数 和 函数要用到的参数 都是父组件提供的, 最好把二者都传递给子组件在子组件执行。 改写前点击计数截图 会造成 rerender 的父组件函数传递方式 import React, { useState, useCallback } from 'react'import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) // 传递 () =&gt; increment(n), 而不是直接传递 increment // 仍然会造成每次 render 生成一个新的函数 return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num onClick={() =&gt; increment(n)} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 相应的子组件直接调用 onClick import React, { useRef } from 'react'export const Num = React.memo(({ onClick, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={onClick}&gt;{n}&lt;/button&gt;}) 改写后点击计数截图 改写后的 父组件import React, { useState, useCallback } from 'react'import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num increment={increment} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 改写后的子组件 export const Num = React.memo(({ increment, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={() =&gt; {increment(n)}}&gt;{n}&lt;/button&gt;})","link":"/2020/01/13/useCallback使用场景/"},{"title":"进程和线程(白话版)","text":"用自己的话理解一下这个貌似对于前端来说貌似重要而不紧急的概念，附有代码示例 概念进程 什么是进程进程就是一个程序运行起来。一个程序可以运行很多份，比如打开多个 vi，运行中的那个程序就是进程。 多进程就是支持同时听歌、上网、QQ。感知上是同时执行，实际上是 cpu 把时间一会给这个一会给那个，cpu 速度很快用户就感受不到切换。 进程之间的通信例子：启动器启动游戏程序怎么做：socket，共享内存 重要的是，多进程之间的通信，传递内容，是操作系统提供API 所有能够做的事情，都是操作系统提供的。 多核的概念运算器、控制器、寄存器组合在一起就是一个CPU。一个CPU有好几套运算器、控制器和缓存就把它叫做多核。双倍核心能提高 10 - 20% 性能就很不错了，一是协作上的消耗，二是软件不会为多核配套。 线程 多线程的概念多进程是一个系统有多个并行的执行序列多线程是一个进程有多个执行序列，有n个线程假设一个程序（一个进程）里面有10个线程操作系统假设给你（进程）分配了10ms（毫秒）那就把10ms平均分配给10 个线程一个进程获得的时间是有限的，多个线程就平均分配这些时间 POSIX标准unix 贝尔实验室出的 太贵 90年代被 linux 革命。linux 免费。IEEE 提出 posix 标准，遵循这个标准就可以和 unix、linux 兼容。 单线程语言在语言层面无法创建一个新的线程。不代表没有多线程，js 有多线程，但是在语言层面不给你用。比如读文件的时候，node 的解释器本身有多线程，在帮你执行。等于说多线程别人帮你做了，给你的接口是单线程的。解释器可以这样做是因为系统给它提供了多线程 api。 同步问题和方案问题 现象存钱 1000 次，取钱 1000 次，最后的结果不一定每次都是0。 执行以下代码： #include &lt;stdio.h&gt;#include &lt;pthread.h&gt;static int balance = 0;void *deposit(void *args) { balance += 1; return NULL;}void *withdrawal(void *args) { balance -= 1; return NULL;}voidthreadDemo() { int n = 1000; pthread_t tid1[n]; pthread_t tid2[n]; for (int i = 0; i &lt; n; i++) { pthread_create(&amp;tid1[i], NULL, deposit, NULL); pthread_create(&amp;tid2[i], NULL, withdrawal, NULL); } for (int i = 0; i &lt; n; i++) { /*等待子线程执行完*/ pthread_join(tid1[i], NULL); pthread_join(tid2[i], NULL); } printf(\"balance %d\\n\", balance);}intmain() { threadDemo(); return 0;} 产生的结果 原因同步问题是因为 balance ++ / balance — 这样的操作背后会被汇编编译成好几个指令，1）从内存中拿数据 2）再在寄存器里操作 3）存回内存 有可能存钱操作和一个取钱操作先后取到了同一个还未被动过的金额数值，取钱的还没算完，存钱操作一下读了3行指令把算好的值存回去了，就产生了存取1000次不一定等于0的情况。 所以根本的解决方案是，一个操作没有做完的时候，不可以对同一块内存的这个变量做另一个操作。 引入术语：原子操作原子是不可拆分的，所以原子操作的意思是这一块代码对应的指令不该被其他线程给拆开。 方案 互斥锁把变量锁起来，完成操作后解锁。这样这个操作就变成了原子操作。 在上面的代码加入如下部分（后面略）： #include &lt;stdio.h&gt;#include &lt;pthread.h&gt;static int balance = 0;// 互斥锁static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;void *deposit(void *args) { // 锁住变量, 解锁前其他变量不可操作 // 加锁可以保证安全, 但会让性能下降 pthread_mutex_lock(&amp;mutex); balance += 1; pthread_mutex_unlock(&amp;mutex); return NULL;}void *withdrawal(void *args) { pthread_mutex_lock(&amp;mutex); balance -= 1; pthread_mutex_unlock(&amp;mutex); return NULL;} 可以看到结果，重复执行100次，每次都是 0 信号量比起上面一种直接锁住的方式，信号量可以控制同时有多少个线程能访问这个资源。如果把限制设置为1，就和上面的互斥锁效果一样。 限制的方式是，设置一个整数变量，进行操作的时候 - 1，要是前面设置的变量被减少到 0 了，另外的线程就停住等待；等操作完了再把前面的整数 + 1。 -1 和 + 1 都是内置的操作，不需要自己写。 #include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;/* 1，信号量本身，用 sem_open 创建的时候要赋予一个值 2，sem_wait 用于把信号量 -1，但信号量为 0 时，这个函数会停住等待 3，sem_post 用于把信号量 +1 这里创建一个值为 1 的信号量 存取钱时候先 wait 再 post*/static int balance = 0;// 信号量变量static sem_t *bankSem;void *deposit(void *args) { // bankSem-1 , 如果 bankSem 是 0 的话就等 // 由于 sem 初始化的值是 1 所以同时只有一个线程能够往下执行代码 sem_wait(bankSem); balance += 10; // bankSem+1 // 这样别的线程才能 sem_wait 成功 sem_post(bankSem); return NULL;}void *withdraw(void *args) { sem_wait(bankSem); balance -= 10; sem_post(bankSem); return NULL;}voidmultiThread(void) { int n = 10000; pthread_t tid1[n]; pthread_t tid2[n]; for (size_t i = 0; i &lt; n; i++) { pthread_create(&amp;tid1[i], NULL, deposit, NULL); pthread_create(&amp;tid2[i], NULL, withdraw, NULL); } for (size_t i = 0; i &lt; n; i++) { pthread_join(tid1[i], NULL); pthread_join(tid2[i], NULL); }}intmain(void) { // 信号量必须初始化 // 名字以 / 开头是最佳建议 // sem_open 创建的信号量可以在不同进程间共享 const char *name = \"/axe_bank\"; // O_CREAT 表示创建信号量 int flag = O_CREAT; int permission = S_IRWXU; // 信号量的值是 1 int value = 1; bankSem = sem_open(name, flag, permission, value); // 多线程存取钱操作 multiThread(); printf(\"balance %d\\n\", balance); // 最后要用下面两个函数删除 sem_close(bankSem); sem_unlink(name); return 0;}","link":"/2020/05/03/进程和线程-白话版/"},{"title":"function light JS 笔记","text":"《你不知道的 JavaScript》作者 Kyle Simpson 新的开源书籍 《functional light JS》主要是讲函数式编程的，记录下其中一些让人印象深刻的点。 前言什么是最好的代码：最好的代码是不需要读的代码。即使只是给代码写 comment, 也应该专注于为什么要这样, 而不是这是什么。 命令式：每一步代码在做什么。声明式：将我们代码的重心放在为什么我们要这个输出，为什么这个输出对我们有用。 函数式更接近于声明式。声明式不是一个绝对的概念, 而是一个相对的概念, 你会认为什么样的代码是声明式和你自己的经验也有关。 纯函数 程序不一定是函数，程序是一系列操作，程序不一定返回结果。 什么是函数？函数不仅接受输入, 也必须返回输出。函数的内部只能调用函数，不能调用程序。 函数是输入和输出之间的关联，要有一个描述这个关系的语义化的名字。函数不会给它之外的变量赋值。 副作用side Effects： I / O (console, files, etc) Database Storage Network Calls DOM Timestamps Random Number 副作用不可能避免, 但是使用的时候应让它们尽可能看起来很明显, 让读者一目了然 const 不可变的定义不仅仅是使用 const 来定义变量, 即使用 var 来定义变量, 在所有代码中变量都没有被重新定义, 这个数据也可以认为是不变的。如果一个函数里直接使用了这个变量, 在调用函数的时候认为这次调用是纯的。 纯函数的定义 我们评判的是函数调用是否纯净, 而不是函数定义是否纯净 纯函数的特征是, 相同的输入, 一定有相同的输出 纯函数不是一个二元对立的概念, 而是开发者对它是一个纯函数的自信程度的高低 提取不纯净的部分将函数中不纯净的部分提取出来成为一段单独的程序 包装不纯的部分 仅在无法改为纯函数 或 无法提取副作用部分时使用 包装新建一个函数把副作用函数包住 使用以下6步改造浅 copy 存下现在的状态创建合适的初始状态调用 副作用程序捕获新状态恢复老状态返回捕获的新状态 参数适配器大多数函数式编程的函数参数都是一元或二元的。 函数的参数区分 parameters 和 arguments, parameters 是函数内容用于接收输入值的变量命名, arguments 是调用函数时的输入值。其实就是形参和实参的概念。 JS 调用函数时不强制要求输入的参数数量和形参一致, 多出的参数会无视, 输入的参数少于形参数量, 未分配到具体值的变量值为 undefined。 使用 functionName.length 可以获取函数的参数数量。 function foo(x, y, z) { // ..}foo.length // 3 arguments 不建议乱用使用 arguments.length 可以获得输入值的数量这是唯一建议直接使用内置 arguments 的场景 function foo(x, y, z) { console.log( arguments.length )}foo(3, 4) // 2 可变函数参数数量不确定的函数使用 …args 作为参数, 会将剩下的没有赋值给形参的入参, 放入一个数组中 function foo(x,y,z,...args) { console.log( x, y, z, args );}foo(); // undefined undefined undefined []foo( 1, 2, 3 ); // 1 2 3 []foo( 1, 2, 3, 4 ); // 1 2 3 [ 4 ]foo( 1, 2, 3, 4, 5 ); // 1 2 3 [ 4, 5 ] 命名参数使用单个对象参数, 实现其他语言命名参数的功能用于实现通过名称传递参数调用函数, 而不依赖于位置 function foo( {x,y} = {} ) { console.log( x, y );}// 通过对象的 key 表示值对应哪个参数, 不必在 x 的位置传入 undefinedfoo( { y: 3} ); // undefined 3 高阶函数定义：以函数作为输入或者返回函数的函数, 一个函数经过高阶函数的改造, 可以改变输入内部函数的参数的形式 参数适配器类型 改变参数数量 改变参数顺序 展开参数 Pointfree概念和基本用法含义：向一个函数传递函数时不标识它们所操作的参数。什么时候可以用：入参的包装函数和返回的函数有同样的参数。 基本用法 getPerson(function onPerson(person) { return renderPerson(person);})// 等价于, 因为外层的函数和里面的函数具有相同的参数 persongetPerson(renderPerson); 把函数改造成 Pointfree 的风格有时候函数一开始不符合这个形式，可以利用 compose 包一层，再变成 pointfree。 如下面的函数 function isOdd(x) { return eq1(mod2(x));} 但是利用 compose 可以将函数改造成 pointfree function compose(fn2, fn1) { return function composed(v) { fn2(fn1(v)); }}// v 可以不写var isOdd = compose(eq1, mod2) 闭包及其应用使用注意事项闭包不一定是纯函数, 但闭包绝对可以在函数式理论中使用。这个例子中闭包记住了入参 fn, 所以 fn 不会被垃圾回收机制清除 function unary(fn) { return function one(arg) { return fn(arg); }} 如果要在函数式编程中使用闭包，必须确认封闭住的是不会改变的值, 一旦你改变封闭住的值，就失去了纯净，可能造成不易排除的 bug。 延迟和立刻 lazy and eager 延迟通过把要执行的代码放到一个包装函数中并返回要延迟执行的函数, 直到返回的函数被调用再执行。适合计算开销大但需要调用它的概率比较低的功能，只在调用的时候计算。 缺点是每次调用都要计算一次。 function repeater(count) { return function allTheAs() { return “”.padStart(count, “A”); }}var A = repeater(5);A(); // “AAAAA” 在这行执行计算A(); // “AAAAA”\u0010 立刻计算在第 7 行执行。优点是只做一次, 即使 A 被调用了 10000 次, 计算只进行一次。缺点是如果 A 从不被调用, 就做了一次不必要的计算。function repeater(count) { var str = “”.padStart(count, “A”); return function allTheAs() { return str; }}var A = repeater(5); // 在这行执行计算A(); // “AAAAA” A(); // “AAAAA”\u0010 Memoization希望功能只执行一次, 但不调用它的时候不执行。继承了延迟的优点, 同时避免了缺点。不要过多使用 memoize, 需要考虑到额外的内存开销, 它会维持永久的的缓存。memoiation 有用的场景是你要多次调用一个函数, 但调用时输入的参数总是相同。如果你推测一个函数要被调用很多次, 但每次的输入都不同, 不要用 memoization, 会占用很多内存。 function repeater(count) { return memoize(function allTheAs() { return “”.padStart(count, “A”); })}var A = repeater(5); // 在这行执行计算A(); // “AAAAA” A(); // “AAAAA”\u0010 从一般化到特殊化 封装函数的目的封装函数的意义不仅是 DRY, 还为了使代码更加语义化, 函数调用的名字可以描述它的目的, 而目的是我们想要告诉读者关键的东西。 函数参数的顺序从左边开始最一般化到右边最特殊化。一般来说, data 更特殊, cb func 更一般化。 特殊化函数的方法 partial applicationpartial() 方法在很多函数式编程库里都有, 用来返回一个预设了一个或多个参数的特殊化函数。第一个参数是函数, 第二个参数是要预设的参数。 柯里化 currying柯里化的意思是，一个函数本来接受 n 个参数作为参数，把它变成执行 n 次，每次执行传入 1 参数，最后得到结果。柯里化比上一种方法更受欢迎。 手动进行柯里化 function ajax(url) { return getData(data) { return getCB(cb){/*. . .*/}; }}var getCustomer = ajax(CUSTOMER_API);var getCurrentUser = getCustomer({ id: 42 }) 一般不需要自己手动写，可以使用 curry 工具函数, 有两种写法。 line1 是标准的柯里化, 每次调用只接受一个函数, 和 Haskel 一样;但大多数函数式编程库提供的是 line2, 进行特殊化时可以传入多个参数, 好处是比较方便 var ajax = curry( 3, function ajax(url, data, cb) {/* . . */})// 标准柯里化, 一次传入一个参数ajax(CUSTOMER_API)({ id: 42 })(renderCustomer);// 可以传入多个参数的柯里化ajax( CUSTOMER_API, { id: 42 } )(renderCustomer); curry 和 partial 对比目的一致, 都是为了特殊化函数partial application 在一开始预设所有参数, 在下一次调用\u0010\u0010\u0010时接受剩下的参数curring 不在一开始预设任何参数, 每次调用只接受一个参数。 既然 curry 更方便和常用, 什么场景下使用 partial application 更好如果有一个 5 个入参的函数, 你想预设 2 个参数, 下次调用时输入另外 3 个参数, 使用 curry 除了要调用两次有点点麻烦之外, 剩下的 3 个参数输入也要调用 3 次, 而你想要获得的函数入参形式是 3 个参数一起输入。这是它仍然存在的原因。 不可变性 IMMUTABILITY定义防止数据意外变化, 只在需要时变化。 赋值不变性 assignment immutability变量不可以被重新赋值。用 const 定义的变量不可以重新被赋值, 但是如果是 array 或 object, 相应的值仍然可被改变。 重新思考 const应该重新思考一下 const 是否那么重要。假设写代码时遵循好的规范, 每个函数不超过 20 行, 那么即使不使用 const, 对变量的重新赋值也会被代码块 { } 的词法作用域限制, 在 20 行内读者也可以清楚地看到这个变量是否被重新赋值了。 一般在一个代码块内用 let 足矣, 用 const 反而会造成困惑, 因为这个词会让读者误认为这个变量的值不会改变( java 里把这个操作从 const 改成了 final, 表示这是最后一次赋值, 而不是值永远不变 (对 java 不太熟哈哈哈，应该查证一下是否是这样？)) 那什么时候适合使用 const 呢？仅当数据天然的不可改变时，一般也就是基本数据类型。 值的不变性 value immutability我们应该更加关注值的不变性, 因为值的传递范围甚至可能到另一个程序。99% 我们遇到的问题都是值在预期之外被改变了, 而不是由于对某个变量重新赋值。 作为使用函数式编程风格的开发者, 应该尝试事先发现可能出现的问题, 并在它们出现前使用能够避免它们的模式。 Object.freeze(obj)可以使对象只读。当使用一个函数时, 如果你要传入一个你并不希望之后被改变的值, 可以用 Object.freeze() 包装一下。这样做的目的不仅是为了让值的性质变为只读, 更是为了告诉读代码的人你并不希望这个值改变。 当你写一个函数, 输入是一个数组或对象, 最好假设输入的值都是不可变的, 做法是复制一个新的数组或对象, 在新的值上面做变动, 保持输入值不变。 不可变的数据结构 Immutable data structures 含义和为什么要用使用不可变数据结构来创建值会被改变的数据, 它使值的变化更可控。 这句话的含义是, 当要改变一个数组或对象的值时, 永远不要改变它们原本的值, 而是复制一个新值来改变。 但是, 如果这个值被改变很多次如1000次, 每次都进行复制的话, 复制和垃圾回收都是性能的开销。 库immutable-js 、 Mori 总结 如果要传入数组、对象这样的数据来调用函数, 应该用类似 Object.freeze 来注释它, 目的是告诉读者不要担心这个值不会被改变。可以封装一个工具函数如命名为 readOnly 来进行使用。 如果是数据的接收方, 无论如何假设它是不可被更改的。 递归 Recursion什么限制了递归的实际使用栈溢出问题, 以前的电脑 RAM 只有 4k。下面的写法, 函数里调用函数的嵌套, 调用栈里可能会叠加 0 到 n 个要执行的函数。也就是直到碰到了 basecase，这 n 层函数才开始一层层的返回值并出栈。 function countVowels(str) { var first = (isVowel(str[0]) ? 1 : 0); if (str.length &lt;= 1) return first; return first + countVowels(str.slice(1));\u0010}countVowels(“These secrets of the inner tribunal of the conscience are known only to the tomb”); ps. 一般现代浏览器允许 20000 个栈叠加。 尾递归优化 tail call优化内存使用, 释放不必要的内存使用, 只会有 0 到 1 内存使用; 并不优化运行速度。主要原理就是相比上面的叠加了 n 次再返回, 变成每一层递归都返回值。 PTC proper tail call解决内存优化到只使用 0-1 的方法, 要素如下:一是使用 严格模式, 在文件最上方声明 “use strict”二是 return 关键字 加 单独的函数调用, 并且在之后没有需要被计算的东西。如果三元表达式的某个分支是一个单独的函数调用, 也符合尾调用。 将上面的 countVowels(str) 改为 PTC 形式 “use strict”// 需要新增一个参数, 用于记下上一次算出来的值进行累加function countVowels(count, str) { count += (isVowel(str[0]) ? 1 : 0); if (str.length &lt;= 1) return count; // 这里直接返回一个函数调用 return countVowels(count, str.slice(1));}countVowels( 0, “These secrets of the inner tribunal of the conscience are known only to the tomb”); Trampoline这是 kyle 推荐用来解决\u0010\u0010\u0010递归层数多浏览器报栈溢出问题的方法。 trampoline 实现 function trampoline(fn) { return function trampolined(…args) { var result = fn(…args); while (typeof result == “function”) { result = result(); } return result; }} 一般的库中都提供这个工具, 使用时只要把递归函数传入即可。 学习资料https://github.com/getify/Functional-Light-JShttps://frontendmasters.com/courses/functional-javascript-v3/","link":"/2020/05/29/function-light-JS-笔记/"},{"title":"广告行业概念及指标扫盲","text":"从行业角色和诉求、广告模式(竞价和非竞价)、广告竞价流程、广告效果指标四方面进行了总结。 程序化广告的行业角色和平台工具1.流量卖方定义：广告流量的卖方一般是媒体。常见类型有 手握流量的单一媒体（今日头条、爱奇艺等） 和 中小流量的聚合方(baiduBES、googleDoubleClick等)。 诉求：媒体的核心诉求是有效利用优质流量和长尾流量，提升流量库存收入，减少库存浪费。 使用平台SSP（Sell-side Platform销售方平台）：媒体可以设定相应的媒体属性（媒体所属分类等信息）、广告位属性（尺寸、可投物料规格）、价格诉求（底价、交易方式等）、投放广告主行业渠道的诉求（允许或禁投不同行业渠道）等。 2.流量买方定义：需要打广告进行产品宣传的广告主或代理商角色如4A广告代理公司和中小代理。 诉求：广告主核心诉求是在合适的时间、合适的地点对合适的人传递合适的信息，提升投放效率。 使用平台DSP（Demand-Side Platform需求方平台）：广告主可以通过DSP平台设置自己想要的受众目标、愿意出多少钱购买这些受众的曝光、投放时间等策略。DSP通过技术和算法自动优化投放效果并提供数据报告。 3.广告交易平台（ADX， Ad Exchange)衔接流量卖方和买方的重要交易平台。流量卖方SSP将广告流量接入广告交易平台ADX中，并设定底价，当有一个广告位要展示给用户时，卖方会通过广告交易平台向买家DSP发起竞价请求。 4.监测方广告主一般不以广告投放方的数据作为依据进行结算，所以需要一个相对独立的第三方检测数据分析放来提供结算依据。国内如秒针、admaster等。 5.数据方（DMP，Data Management Platform）整合各方数据并提供数据分析，数据管理、数据调用等，用来指导广告主进行广告优化和投放决策。 常见广告交易模式（不限于程序化广告）程序化广告程序化广告分为 竞价 和 固定价 两类。1.RTB（Real Time Bidding实时竞价）公开竞价OA（Open Auction）产生原因：卖方（媒体）黄金点位有限，长尾媒体资源较多；买方（广告主）需要跨媒体针对特定人群进行广告采买。模式特点：广告主可以在公开交易市场进行实时竞价购买剩余流量。整个过程都是通过程序化的方式在100毫秒以内完成的。 ADX卖方和买方DSP之间按照竞价成功金额进行结算，广告主同DSP方按照第三方检测为依据来结算，所以DSP方需要承担这个价差（所以广告投放方和第三方检测或广告主观测到的数据差异涉及广告结算，所以十分敏感） 2.RTB私有竞价PA（Private Auction）产生原因：流量卖方希望好流量可以卖个好价钱，安排一些优质广告主组成一个VIP竞价俱乐部，将流量先进行私有竞价再进入公开交易。模式特点：该模式属于RTB竞价范畴。存在竞价环节，但买方相对公开竞价更少，成交价和成交量都不固定。入场买家要提前申请deal ID。 3.私有程序化购买PDB（Programmatic Direct Buy）产生原因：这个模式主要满足资金充足的大品牌广告主想提高自己包段的黄金资源流量投放效率的需求。模式特点：在仍旧采用传统排期模式采买流程的前提下，通过程序化做到在合适的时间、合适的地点对合适的人展示合适的广告。 中间不存在竞价环节，价格事先线下约定。 4.优先交易PD产生原因：前面的PDB模式不允许广告主将非预期目标用户的曝光量退还给媒体，属于保价保量的模式。与之对应产生了保价不保量的PD模式，卖方（媒体）将传统排期售卖点位预定剩下的流量通过该方式出售。模式特点：流量卖方事先和买方事先约定好一个相对较高固定价格（高于RTB公开竞价底价），且买卖双方不承诺量。卖方的邀请投放广告请求来的时候若程序化买家判定这个流量是自己想通过PD优先权来获取的，就会返回PD索要响应，即可优先获得该次曝光机会。 传统模式1.传统排期广告投放“传统”互联网展示类广告都是以CPT、按位置及时间包段的广告合约方式进行售卖的。 程序化广告中的RTB竞价流程1.业务流程 2.OpenRTB协议的处理时序图 广告请求中会带上媒体广告资源位相关属性的数据字段和用户行为数据如Geo、Device、Age等。这些数据段中的数据是分析用户行为及机器学习建立模型十分重要的因子维度。 广告效果/结算常见指标 常规类及偏品牌类指标·PV（Pageview，浏览量）：网站各网页中被浏览的总次数。一个访客有可能创造十几个，甚至更多的PV；·Impression（广告曝光数）：广告被展示的次数，即用户每浏览一次网页，同时页面广告位中的广告被展示一次，就是一个Impression；·UV（Unique Visitor，独立访客）：访问网站或看到广告的一台电脑客户端或手机客户端为一个访客。·Click（点击次数）：用户点击广告的次数；·CTR（Click Through Rate，点击率）：广告被点击的次数与广告被曝光次数的比例，即Click/Impression。·IP（Internet Protocol，独立IP地址）：指独立IP地址数。·Cost（广告消耗）：即广告投放实际总共花了多少钱。·CPM（Cost Per Thousand Impression，每千次曝光数成本）：广告主为自己的广告显示1000次所付的费用；·CPC（Cost-per-click，点击成本）：每次点击的费用。根据广告被点击的次数收费。CPC是评估广告效果的指标之一。·Landing Page（落地页）：广告被点击后打开的页面俗称“落地页”。·Landing Rate：落地页PV数/广告点击数，主要用于分析点击效率。·CPUV（Cost-Per-UV）：即每个UV的消耗，每获得一个UV所付出的成本。·CR（Conversion Rate，转化率）：是指访问某一网站访客中，转化的访客占全部访客的比例。·二跳率：网站页面打开后，用户在页面上产生的首次点击被称为“二跳”，二跳的次数即为”二跳量”，二跳量与浏览量的比值称为页面的二跳率。·跳出率：是指浏览了一个页面就离开的用户，占一组页面或一个页面访问次数的百分比。·人均访问页面：即PV总和/UV。 偏效果类指标·CPA（Cost-per-Action）：根据广告最终投放的效果，即回应或者激活的数量收费，而不是广告的投放量。汽车行业常见CPL（Cost-per-Lead，收集试乘试驾销售线索）。·CPS（Cost-Per-Sale）：以实际销售产品数量来计算广告费用，即分成模式结算。·CPV（Cost-Per-Visit）：每个访问（Visit）的成本。即发布不收费，展示不收费，点击不收费，只是按照浏览指向网站的有意向客户数量收费的。·CPDownLoad（Cost-Per-DownLoad）：按照每次下载收费，下载就付费，不管是否安装，当然不同渠道的下载到激活转化率不同的。·ROI（Return On Investment）：投资回报率。·重复购买率：指消费者在网站中的重复购买次数。·客单价：是指每一个订单的平均购买商品金额，也就是平均交易金额。 参考《程序化广告实战》《程序化广告生态实用手册》《程序化广告投放指南》","link":"/2020/04/04/广告行业概念扫盲/"},{"title":"异步和Promise执行过程图解","text":"为什么会有异步JavaScript 是单线程按照代码顺序一行行执行的, 按理说常规的代码应该是同步执行的：遇到函数调用形如 functionName(params) 时, 将函数放入 Call Stack 调用栈中执行, 执行完后从调用栈中 pop 出并返回结果, 再继续执行下一行代码。 但平时我们用 JavaScript 所写的很多功能并不是 JavaScript, 而是 JS 调用外部接口来实现的, 如 Web Browser APIs（而浏览器是用 c++ 实现的相应功能）。这些功能的执行并不是在 JS 的函数调用栈中, 而是在浏览器中, 并不会阻塞 JS 继续执行后面的代码, 这就形成了异步。 在这样的背景下, 我们在执行诸如数据请求这类比较耗时的操作时, 和远程建立连接并取回数据的活实际是浏览器在做, 而不是 JS, 所以任务并不会放到 JS 的调用栈中, JS 仍然不受影响继续往下执行, 从而不会造成用户在等待数据返回期间页面完全不能操作的情况。 异步的含义异步代码不按照看到的顺序执行, 当异步执行的函数返回给 JS 时, JS 才处理它。 区分浏览器和 JS 的世界平时我们使用 JS 做的很大一部分都不是 JS 的功能, 而是浏览器的功能。例如, setTimeout 是浏览器的定时器功能, “setTimeout” 是 JS 和浏览器交互的 API。JS 同样没有发送网络请求的能力, 这也是浏览器提供的功能。 下面这些常用功能容易被误认为是 JS 的功能, 但实际上是浏览器的功能，JS 只是调用了浏览器的 API。 console - consolesocketsNetwork request - xhr、fetchHTML DOM - DocumentTimer - setTimeoutlocalStorage - localStorageIndexedDB PS. 虽然这些功能很常用, 但知道了这件事, 我才明白了为什么说 node.js 是可以脱离浏览器环境执行的语言。 Callback Queue 和 event loopCallback Queue示例和说明1先通过下面一段定时器代码来说明一下异步执行的过程。 function printHello(){ console.log(\"Hello\") }setTimeout(printHello,1000)console.log(\"Me first!\") 第一行在 global memory 中定义了一个名为 printHello 的函数。 执行到第二行时, JS 做的是调用一下浏览器里的定时器功能, 调用后不需要等到 1000ms 结束, JS 已经完成了呼叫浏览器帮忙计时的任务, 直接去往下一行了。这里浏览器里的 printHello 是一个引用, 而不是复制了一份代码。与此同时, 浏览器的定时器开始计时, 看是否到了 1000ms, 这和 JS 代码执行是分开独立的。 JS继续执行第三行, 在 console 里打印 “Me first!”, 此时常规的 JS 代码已经执行完成, 时间可能过去了 1ms 还不到。但是浏览器仍在在后台“滴滴答答”地执行计时。 到了 1000ms 时, 计时结束, printHello 调头回到 JS 的执行环境, 并被放回 JS 的Callback Queue 回调队列中, 这个队列并不做执行的工作, 和 Call Stack 也是相互独立的。由于此时 global 中的代码也都执行完了(也就是所有 JS 代码都按顺序执行完了), printHello 从 Callback Queue 出队, 进入 JS 函数调用栈, 执行。 示例和说明2继续看一个例子。现在把上面的定时器时间改为 0ms, 并增加一个常规的 JS 函数, 并假设这个函数需要 1s 的执行时间。 function printHello(){ console.log(\"Hello\") }function blockFor1Sec(){ // 假设这个函数执行需要 1000ms }setTimeout(printHello,0)blockFor1Sec()console.log(\"Me first!\") 打印出来的顺序如下, 虽然定时器设置的是 0s, 仍在最后打印出来 这是因为即使计时时间是 0ms, 0ms结束时, printHello 进入的是 Callback Queue, JS 会优先执行完 Call Stack 中的函数, 再将 Callback Queue 中的函数挪到 Call Stack 中执行。 下面来看具体的执行过程, 从函数定义后调用 setTimeout 开始0ms 调用 setTimeout, 浏览器计时, 计时结束后 printHello 先进入 Callback Queue等待。 1ms JS 执行调用栈最底下的 global(), 执行下一行, 调用 blockFor1Sec。 1001ms 执行 blockFor1Sec 用了 1s, 这时候执行 global() 的代码, 到下一行调用 console.log(‘Me First!’)。printHello 仍然在回调队列中等待。 1002ms global 中所有的代码都执行完了, printHello 从回调队列中出队, 压入调用栈。 规则总结将函数从 Callback Queue 中移入调用栈中的时机是所有的同步代码都执行完毕后。应用这个规则, 就可以确定函数执行的顺序。 event loop那么 JS 是如何知道可以执行 callback 中的内容的呢, 这就涉及了关键的 event loop 机制。event loop 在每一行代码执行前, 都会不停检查: 1.Call Stack 中的函数是否全部执行完了, 也包括调用栈最底下全局环境下的代码是否执行完了。 2.Callback Queue 中是否有待执行函数。 3.当 Call Stack 中所有的代码都执行完, 就会去 Callback Queue 中把函数移入 Call Stack 中执行。 Promises 和 Microtask QueuePromise 对象以 fetch 为例, 执行 fetch 会同时做两件事, 一是在 JS 中返回一个 Promise 对象, 另一方面, 在浏览器中, 会触发浏览器来进行网络请求。 其返回的 Promise 对象的属性如下, 这些属性都不能使用点语法取得: 1.value: 默认值是 null, 当浏览器请求的数据返回了, global 代码执行完成后, 会立刻自动更新 value 的值。 2.onFulfilled： 默认是空数组, .then() 中要执行的函数会 push 到这个数组中。当网络请求返回了数据, value 的值更新后, 数组中的函数会进入 Microtask Queue 微任务队列, 等待执行。 3.onRejection: 默认是一个空数组。.catch() 中要执行的函数会 push 到这个数组中。 会返回 Promise 对象的内置函数可以在 MDN 上查到。 Microtask QueuePromise 对象 .then() 方法中的回调函数在返回值更新后会进入微任务队列, 它和前面说的回调队列是独立的, 并且里面的函数执行优先级高于回调队列。微任务队列中的函数同样是先进先出。 执行过程示例示例代码function display(data){console.log(data)}function printHello(){console.log(\"Hello\")}function blockFor300ms(){ // 假设这个函数执行需要 300ms }setTimeout(printHello, 0)const futureData = fetch('https://twitter.com/will/tweets/1')futureData.then(display)blockFor300ms()console.log(\"Me first!\")// 输出顺序// Me first!// data 的值// Hello 执行过程从3个函数定义后开始, 上述代码执行过程如下: 0ms 触发浏览器的定时器功能计时 0 ms, 0ms 计时完成, printHello 进入 Callback 队列 1ms 执行 fetch(), 返回一个 Promise 对象给 futureData 标签, 同时告诉浏览器进行网络请求（包括 主机名、地址、方法这些信息） 执行 fetchData.then(display), 将 display 方法存入 Promise 对象 onFulfilled 属性对应的数组中 2ms 执行 blockFor300ms, 这个程序执行要 300ms, 这是同步代码所以 JS 会在 300ms 后再执行下一行 270ms 假设此时异步请求的数据返回了, Promise 对象 futureData 的 value 属性值会更新为请求回来的数据。同时自动将 Promise 对象 onFulfilled 数组中的函数, 注册进 Microtask Queue。 302ms blockFor300ms 执行完了, global 中还有代码, 所以继续执行下一行 console.log(“Me first”), 会直接在 console 输出内容。 303ms 整个过程中 eventloop 一直在进行检测, 此时调用栈中没有函数在执行, global 中的代码也执行完了; Microtask Queue 和 Callback Queue 中都有待执行的函数, 优先将 Microtask Queue 中的函数“移入”调用栈。在 console 打印出 data 的值。 304ms 调用栈 和 Microtask Queue 都空了, 将 Callback Queue 中的 printHello “移入”调用栈中执行。在 console 面板中输出 “Hello”。 总结分类1.常规的同步代码函数调用都会直接进入 Call Stack 调用栈中, 以最高优先级调用 2.老的回调 Api, 如 setTimeout, 其回调函数会进入 Callback Queue 中 3.所有通过 then 方法附属于某个 Promise 对象的函数, 当 Promise 对象 value 属性的值自动更新时, 进入 Microtask Queue 中 执行顺序0.优先执行完 Call Stack 中的函数, 和 global 中的代码, 直到所有代码都执行完 1.其次将 Microtask Queue 中的函数移入 Call Stack 中执行 2.最后将 Callback Queue 中的函数移入 Call Stack 中执行 学习资料视频： JavaScript: The Hard Parts, v2","link":"/2020/01/29/异步和Promise执行过程图解/"}],"tags":[],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}