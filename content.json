{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about~~~~","text":"","link":"/about/about.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"git checkout/reset/revert/clean 区别","text":"这四个 git 命令主要用于修复错误时重置文件, 但是它们来取消变更什么区别和注意事项呢？ git checkout同时恢复工作区和暂存区, 参数是否带有文件名时表现不一致, 不带文件名时间 CHECKOUT BRANCH1.改变 HEAD 的指向到指定 branch2.把提交时的代码复制到暂存区(staging area)3.更新工作区(working area)的内容 CHECKOUT - - &lt;FILE&gt;1.将当前 暂存区 的文件覆盖到工作区。 CHECKOUT &lt;COMMIT&gt; - - FILE从指定的提交恢复文件, 也可以恢复删除的文件, 只要指定删除文件的那个提交的父提交即可1.从指定提交恢复对应文件到暂存区2.再从暂存区恢复对应文件到工作区 git clean删除工作区里未提交到暂存区的文件使用 –dry-run 查看会删除的文件, 使用 -f 执行删除, 使用 -d 清空文件夹 git reset根据后面所跟参数的不同有不一致的表现 RESET &lt;COMMIT&gt;根据 flag 的不同有如下表现—soft = 1—mix = 1 &amp; 2 默认是 mix—hard = 1 &amp; 2 &amp; 31.移动 HEAD 和 branch 到指定的提交&lt;COMMIT&gt;, 会改变提交历史2.重置暂存区的文件和指定提交一致3.重置工作区的文件和指定提交一致 GIT RESET — &lt;FILE&gt;不移动 HEAD, 将 HEAD 所指分支的对应文件覆盖到 暂存区 GIT RESET &lt;COMMI &gt; — &lt;FILE&gt;1.不移动 HEAD, 将指定提交的对应文件覆盖到暂存区 撤销 git resetgit reset ORIG_HEADgit 会将重置之前的 HEAD 存在 ORIG_HEAD 中, 执行 git reset ORIG_HEAD 可以回到(意外执行想要撤销的) git reset - 之前的状态 git revert &lt;commit&gt;更安全的 reset。直接取消对应提交的所有变更, 产生一个新的 commit, 不会改变变更历史 参考资料及图片来源git-in-depth Nina","link":"/2020/02/17/git-checkout-reset-revert-clean-区别/"},{"title":"useCallback使用场景说明和举栗","text":"使用 react hooks 时, 父组件向子组件传递函数 或 在 useEffect 中使用外部函数, 如果不做任何处理会出现 组件重复渲染 或 useEffect 中的逻辑被不停触发的情况, 一般这个时候 react-hooks 的 lint 也会报错。这种情况可以使用 useCallback 来将原函数包装一层再传到需要用的地方, 避免异常情况。 本文介绍了什么时候应该使用 useCallback, useCallback 如何和 React.memo() 配合使用, 并附上示例代码及gif截屏, 方便更直观的理解。 基本用法把你要的函数用 useCallback 包一层, 定义好只有什么参数变化时, 这个被包过的函数才需要更新 const yourfunc = useCallback( () =&gt; { // 你要写的函数逻辑 }, [ // 在数组里定义什么参数改变时才需要更新 yourfunc, // 只要这里的依赖的参数没有变对于任何使用它的一方它都没有变 ]) 使用场景1.父组件向子组件传递函数时, 阻止传递的函数在每次 render 时重新创建，从而造成子组件 rerender。需要配合 React.memo() 一起使用。 2.在 useEffect（） 中使用外部创建的函数, 但不希望这个函数一直变化, 导致 useEffect 被重复触发。 栗子🌰1.父组件传递函数给子组件 使用 useCallback 前，父组件直接传函数给子组件的方式。每次 app render 时, 传递的函数 () =&gt; setCount(count + 1) 都会重新创建一次。每次点击 hello 按钮，都会进行 render。 上图 log 是打在子组件 &lt;Hello \u0010/&gt; 中的, 从log可以看到, 每次点击按钮都会造成子组件 rerender。 使用 useCallback 前的父组件 import React, { useState } from 'react'import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // 需要注意, 每次 render 传递的函数都会重新生成 // 也就是下面的 () =&gt; setCount(count + 1) return ( &lt;div&gt; &lt;Hello increment={() =&gt; setCount(count + 1)} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 子组件子组件中 React.memo() 的作用类似于 class 组件中的 shouldComponentUpdate, 会对组件接受到的 props进行浅比较, 如果 props 没有发生变化，组件就不会 rerender. 如果这里把 React.memo() 去掉, 那即使父组件使用 useCallback 改写。子组件 还是会 rerender。 import React, { useRef } from 'react'// 使用 React.memo 使组件仅在 props 更新时更新// 未使用 useCallback 时, 由于每次传递过来的 increment 接到的函数都会更新, 子组件每次都会rerenderexport const Hello = React.memo(({ increment }) =&gt; { // 下面两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={increment}&gt;hello&lt;/button&gt;}) 使用 useCallback 改写父组件后, 每次更新数据组件不再重新渲染, 如图 使用 useCallback 改写原父组件, 子组件不需要修改import React, { useState, useCallback } from 'react'import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // useCallback 仅将 setCount 作为依赖, 只要 setCount 不改变, // increment 函数就不会改变 // 相应的子组件接受到的 props 没改变, 就不会 rerender const increment = useCallback(() =&gt; { setCount(prevCount =&gt; prevCount + 1) }, [setCount]) return ( &lt;div&gt; &lt;Hello increment={increment} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 使用 map 渲染多个子组件并传递函数给它们 下面的计数器将一个数字构成的数组渲染成多个按钮, 点击按钮给 count 增加相应的值。与上面的例子不同的是, 这里的 increment 需要传入对应的数字, 进行相应计数。放上这个例子是为了说明, 如果 子组件要执行的函数 和 函数要用到的参数 都是父组件提供的, 最好把二者都传递给子组件在子组件执行。 改写前点击计数截图 会造成 rerender 的父组件函数传递方式 import React, { useState, useCallback } from 'react'import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) // 传递 () =&gt; increment(n), 而不是直接传递 increment // 仍然会造成每次 render 生成一个新的函数 return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num onClick={() =&gt; increment(n)} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 相应的子组件直接调用 onClick import React, { useRef } from 'react'export const Num = React.memo(({ onClick, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={onClick}&gt;{n}&lt;/button&gt;}) 改写后点击计数截图 改写后的 父组件import React, { useState, useCallback } from 'react'import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num increment={increment} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 改写后的子组件 export const Num = React.memo(({ increment, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={() =&gt; {increment(n)}}&gt;{n}&lt;/button&gt;})","link":"/2020/01/13/useCallback使用场景/"},{"title":"useRef使用场景说明和举例","text":"使用场景 用于获取并存放组件的 dom 节点, 以便直接对 dom 节点进行原生的事件操作，如果监听事件或进行大小测量。 利用 useRef 解决由于 hooks 函数式组件产生闭包时无法获取最新 state 的问题。 存放想要持久化( instant )的数据, 该数据不和 react 组件树的渲染绑定。该数据可以是任何类型，数字、数组、对象、函数，都可以。 示例代码如下 用法获取 dom 节点React 的典型用法是更改 props 来更新UI，但有些情况如触发滚动时回调、获取元素大小等，需要直接获取并存储组件的 dom 节点的引用, 以便对其直接进行操作。 使用 useRef 存放并打印出的 dom 节点如图 示例代码如下 import React, { useRef } from 'react'export default function InputFocus() { const inputRef = useRef() return &lt;div&gt; &lt;input name=\"input\" ref={inputRef}&gt;&lt;/input&gt; &lt;button onClick={() =&gt; { // 通过 .current 拿到当前 dom 元素 // 可使用原生 dom 事件 inputRef.current.focus() console.log('ref', inputRef.current) }}&gt; focus &lt;/button&gt; &lt;/div&gt;} 解决使用 hooks 时由于闭包无法获取最新 state 的问题用 useRef 解决闭包导致无法获取最新 state 的问题。会出现这样的问题是由于 hooks 组件本质上是一个函数, 不像 class 组件由于可以直接获取到实例变量从而获取到准确的最新值。 下图为在 setTimeout 中进行弹窗并显示 state 和 ref.current 的值, 可以看到 state 的数字由于闭包拿到的是上一个版本的 state, 而 ref 的值更新了。 示例代码如下 import React, { useState, useEffect, useRef } from \"react\"const RefComponent = () =&gt; { // 使用 useState 存放和改变展示的 number const [stateNumber, setStateNumber] = useState(0) // 使用 useRef 生成一个独立的 ref 对象 // 在它的 current 属性单独存放一个展示的 number, 初始值为 0 const numRef = useRef(0) function incrementAndDelayLogging() { // 点击按钮 stateNumber + 1 setStateNumber(stateNumber + 1) // 同时 ref 对象的 current 属性值也 + 1 numRef.current++ // 定时器函数中产生了闭包, 这里 stateNumber 的是组件更新前的 stateNumber 对象, 所以值一直会滞后 1 setTimeout( () =&gt; alert(`state: ${stateNumber} | ref: ${numRef.current}`), 1000 ) } // 直接渲染的组件是正常情况, 可以获取到最新的 state, // 所以 ref.current 和 state 存储的值显示一致 return ( &lt;div&gt; &lt;h1&gt;solving closure by useRef&lt;/h1&gt; &lt;button onClick={incrementAndDelayLogging}&gt;alert in setTimeout&lt;/button&gt; &lt;h4&gt;state: {stateNumber}&lt;/h4&gt; &lt;h4&gt;ref: {numRef.current}&lt;/h4&gt; &lt;/div&gt; )}export default RefComponent 其他场景下存放任何想要存的数据可以在任何我们需要的时候更新 ref.current , 并且不会由于它的更新造成 rerender, 所以在下例中可以用它来计算组件更新次数。 import React, { useRef } from 'React'export const RenderCount() { const renders = useRef(0) console.log('renders:': renders.current++) // 组件每次渲染更新次数 return &lt;div&gt;Hello&lt;/div&gt;}","link":"/2020/02/17/useRef使用场景说明和举例/"},{"title":"异步和Promise执行过程图解","text":"为什么会有异步JavaScript 是单线程按照代码顺序一行行执行的, 按理说常规的代码应该是同步执行的：遇到函数调用形如 functionName(params) 时, 将函数放入 Call Stack 调用栈中执行, 执行完后从调用栈中 pop 出并返回结果, 再继续执行下一行代码。 但平时我们用 JavaScript 所写的很多功能并不是 JavaScript, 而是 JS 调用外部接口来实现的, 如 Web Browser APIs（而浏览器是用 c++ 实现的相应功能）。这些功能的执行并不是在 JS 的函数调用栈中, 而是在浏览器中, 并不会阻塞 JS 继续执行后面的代码, 这就形成了异步。 在这样的背景下, 我们在执行诸如数据请求这类比较耗时的操作时, 和远程建立连接并取回数据的活实际是浏览器在做, 而不是 JS, 所以任务并不会放到 JS 的调用栈中, JS 仍然不受影响继续往下执行, 从而不会造成用户在等待数据返回期间页面完全不能操作的情况。 异步的含义异步代码不按照看到的顺序执行, 当异步执行的函数返回给 JS 时, JS 才处理它。 区分浏览器和 JS 的世界平时我们使用 JS 做的很大一部分都不是 JS 的功能, 而是浏览器的功能。例如, setTimeout 是浏览器的定时器功能, “setTimeout” 是 JS 和浏览器交互的 API。JS 同样没有发送网络请求的能力, 这也是浏览器提供的功能。 下面这些常用功能容易被误认为是 JS 的功能, 但实际上是浏览器的功能，JS 只是调用了浏览器的 API。 console - consolesocketsNetwork request - xhr、fetchHTML DOM - DocumentTimer - setTimeoutlocalStorage - localStorageIndexedDB PS. 虽然这些功能很常用, 但知道了这件事, 我才明白了为什么说 node.js 是可以脱离浏览器环境执行的语言。 Callback Queue 和 event loopCallback Queue示例和说明1先通过下面一段定时器代码来说明一下异步执行的过程。 function printHello(){ console.log(\"Hello\") }setTimeout(printHello,1000)console.log(\"Me first!\") 第一行在 global memory 中定义了一个名为 printHello 的函数。 执行到第二行时, JS 做的是调用一下浏览器里的定时器功能, 调用后不需要等到 1000ms 结束, JS 已经完成了呼叫浏览器帮忙计时的任务, 直接去往下一行了。这里浏览器里的 printHello 是一个引用, 而不是复制了一份代码。与此同时, 浏览器的定时器开始计时, 看是否到了 1000ms, 这和 JS 代码执行是分开独立的。 JS继续执行第三行, 在 console 里打印 “Me first!”, 此时常规的 JS 代码已经执行完成, 时间可能过去了 1ms 还不到。但是浏览器仍在在后台“滴滴答答”地执行计时。 到了 1000ms 时, 计时结束, printHello 调头回到 JS 的执行环境, 并被放回 JS 的Callback Queue 回调队列中, 这个队列并不做执行的工作, 和 Call Stack 也是相互独立的。由于此时 global 中的代码也都执行完了(也就是所有 JS 代码都按顺序执行完了), printHello 从 Callback Queue 出队, 进入 JS 函数调用栈, 执行。 示例和说明2继续看一个例子。现在把上面的定时器时间改为 0ms, 并增加一个常规的 JS 函数, 并假设这个函数需要 1s 的执行时间。 function printHello(){ console.log(\"Hello\") }function blockFor1Sec(){ // 假设这个函数执行需要 1000ms }setTimeout(printHello,0)blockFor1Sec()console.log(\"Me first!\") 打印出来的顺序如下, 虽然定时器设置的是 0s, 仍在最后打印出来 这是因为即使计时时间是 0ms, 0ms结束时, printHello 进入的是 Callback Queue, JS 会优先执行完 Call Stack 中的函数, 再将 Callback Queue 中的函数挪到 Call Stack 中执行。 下面来看具体的执行过程, 从函数定义后调用 setTimeout 开始0ms 调用 setTimeout, 浏览器计时, 计时结束后 printHello 先进入 Callback Queue等待。 1ms JS 执行调用栈最底下的 global(), 执行下一行, 调用 blockFor1Sec。 1001ms 执行 blockFor1Sec 用了 1s, 这时候执行 global() 的代码, 到下一行调用 console.log(‘Me First!’)。printHello 仍然在回调队列中等待。 1002ms global 中所有的代码都执行完了, printHello 从回调队列中出队, 压入调用栈。 规则总结将函数从 Callback Queue 中移入调用栈中的时机是所有的同步代码都执行完毕后。应用这个规则, 就可以确定函数执行的顺序。 event loop那么 JS 是如何知道可以执行 callback 中的内容的呢, 这就涉及了关键的 event loop 机制。event loop 在每一行代码执行前, 都会不停检查: 1.Call Stack 中的函数是否全部执行完了, 也包括调用栈最底下全局环境下的代码是否执行完了。 2.Callback Queue 中是否有待执行函数。 3.当 Call Stack 中所有的代码都执行完, 就会去 Callback Queue 中把函数移入 Call Stack 中执行。 Promises 和 Microtask QueuePromise 对象以 fetch 为例, 执行 fetch 会同时做两件事, 一是在 JS 中返回一个 Promise 对象, 另一方面, 在浏览器中, 会触发浏览器来进行网络请求。 其返回的 Promise 对象的属性如下, 这些属性都不能使用点语法取得: 1.value: 默认值是 null, 当浏览器请求的数据返回了, global 代码执行完成后, 会立刻自动更新 value 的值。 2.onFulfilled： 默认是空数组, .then() 中要执行的函数会 push 到这个数组中。当网络请求返回了数据, value 的值更新后, 数组中的函数会进入 Microtask Queue 微任务队列, 等待执行。 3.onRejection: 默认是一个空数组。.catch() 中要执行的函数会 push 到这个数组中。 会返回 Promise 对象的内置函数可以在 MDN 上查到。 Microtask QueuePromise 对象 .then() 方法中的回调函数在返回值更新后会进入微任务队列, 它和前面说的回调队列是独立的, 并且里面的函数执行优先级高于回调队列。微任务队列中的函数同样是先进先出。 执行过程示例示例代码function display(data){console.log(data)}function printHello(){console.log(\"Hello\")}function blockFor300ms(){ // 假设这个函数执行需要 300ms }setTimeout(printHello, 0)const futureData = fetch('https://twitter.com/will/tweets/1')futureData.then(display)blockFor300ms()console.log(\"Me first!\")// 输出顺序// Me first!// data 的值// Hello 执行过程从3个函数定义后开始, 上述代码执行过程如下: 0ms 触发浏览器的定时器功能计时 0 ms, 0ms 计时完成, printHello 进入 Callback 队列 1ms 执行 fetch(), 返回一个 Promise 对象给 futureData 标签, 同时告诉浏览器进行网络请求（包括 主机名、地址、方法这些信息） 执行 fetchData.then(display), 将 display 方法存入 Promise 对象 onFulfilled 属性对应的数组中 2ms 执行 blockFor300ms, 这个程序执行要 300ms, 这是同步代码所以 JS 会在 300ms 后再执行下一行 270ms 假设此时异步请求的数据返回了, Promise 对象 futureData 的 value 属性值会更新为请求回来的数据。同时自动将 Promise 对象 onFulfilled 数组中的函数, 注册进 Microtask Queue。 302ms blockFor300ms 执行完了, global 中还有代码, 所以继续执行下一行 console.log(“Me first”), 会直接在 console 输出内容。 303ms 整个过程中 eventloop 一直在进行检测, 此时调用栈中没有函数在执行, global 中的代码也执行完了; Microtask Queue 和 Callback Queue 中都有待执行的函数, 优先将 Microtask Queue 中的函数“移入”调用栈。在 console 打印出 data 的值。 304ms 调用栈 和 Microtask Queue 都空了, 将 Callback Queue 中的 printHello “移入”调用栈中执行。在 console 面板中输出 “Hello”。 总结分类1.常规的同步代码函数调用都会直接进入 Call Stack 调用栈中, 以最高优先级调用 2.老的回调 Api, 如 setTimeout, 其回调函数会进入 Callback Queue 中 3.所有通过 then 方法附属于某个 Promise 对象的函数, 当 Promise 对象 value 属性的值自动更新时, 进入 Microtask Queue 中 执行顺序0.优先执行完 Call Stack 中的函数, 和 global 中的代码, 直到所有代码都执行完 1.其次将 Microtask Queue 中的函数移入 Call Stack 中执行 2.最后将 Callback Queue 中的函数移入 Call Stack 中执行 学习资料视频： JavaScript: The Hard Parts, v2","link":"/2020/01/29/异步和Promise执行过程图解/"}],"tags":[],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}