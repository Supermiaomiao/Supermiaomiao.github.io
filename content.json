{"pages":[{"title":"about~~~~","text":"","link":"/about/about.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"useCallback使用场景","text":"使用场景 父组件向子组件传递函数时, 阻止传递的函数在每次 render 时重新创建，从而造成子组件 rerender something the other case where you want to use useCallback is in a case where you’re using for example like useEffect and you have some logic and you need to pin on this increment function you don’t want this function to be changing all the time or else that useEffect will keep firing off 相应的例子 父组件传递函数给子组件 使用 useCallback 前，父组件直接传函数给子组件的方式。每次 app render 时, 传递的函数 () =&gt; setCount(count + 1) 都会重新创建一次。每次点击 hello 按钮，都会进行 render。 使用 useCallback 前的父组件 1234567891011121314import React, { useState } from \"react\"import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // 需要注意, 每次 render 传递的函数都会重新生成 // 所以下面 () =&gt; setCount(count + 1) return ( &lt;div&gt; &lt;Hello increment={() =&gt; setCount(count + 1)} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 子组件 123456789101112import React, { useRef } from \"react\";// 使用 React.memo 使组件仅在 props 更新时更新// 未使用 useCallback 时, 由于每次传递过来的 increment 接到的函数都会更新,// 组件每次都会渲染export const Hello = React.memo(({ increment }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) return &lt;button onClick={increment}&gt;hello&lt;/button&gt;}) 使用 useCallback 包装要传递的函数后, 每次更新数据组件不再重新渲染 使用 useCallback 改写原父组件 1234567891011121314151617181920import React, { useState, useCallback } from \"react\"import { Hello } from './hello'export default function Counter() { const [count, setCount] = useState(0) // useCallback 仅将 setCount 作为依赖, 只要 setCount 不改变, // increment 函数就不会改变 // 相应的子组件接受到的 props 没改变, 就不会 rerender const increment = useCallback(() =&gt; { setCount(prevCount =&gt; prevCount + 1) }, [setCount]) return ( &lt;div&gt; &lt;Hello increment={increment} /&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 使用 map 渲染多个子组件并传递函数下面的计数器将一个数字构成的数组渲染成多个按钮, 点击按钮给 count 增加相应的值。由于直接传递了 会造成 rerender 的父组件函数传递方式 1234567891011121314151617181920212223242526import React, { useState, useCallback } from \"react\"import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num onClick={() =&gt; increment(n)} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 应该将函数改写为 改写后的 父组件 1234567891011121314151617181920212223242526import React, { useState, useCallback } from \"react\"import { Num } from './numbers'export default function Counter() { const [count, setCount] = useState(0) const nums = [3, 33, 333] const increment = useCallback(n =&gt; { setCount(prevCount =&gt; prevCount + n) }, [setCount]) return ( &lt;div&gt; { nums.map(n =&gt; &lt;Num increment={increment} n={n} key={n} /&gt; ) } &lt;div&gt;count: {count}&lt;/div&gt; &lt;/div&gt; )} 改写后的子组件 12345678910111213141516import React, { useRef } from \"react\";// 使用 React.memo 使组件仅在 props 更新时更新// 未使用 useCallback 时, 由于每次传递过来的 increment 接到的函数都会更新,// 组件每次都会渲染export const Num = React.memo(({ increment, n }) =&gt; { // 以下两句用来查看组件更新的次数 const renderCount = useRef(0) console.log('render count:', renderCount.current++) const onClick = n =&gt; { increment(n) } return &lt;button onClick={() =&gt; {onClick(n)}}&gt;{n}&lt;/button&gt;})","link":"/2020/01/13/useCallback使用场景/"}],"tags":[],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}